<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[generator方法]]></title>
    <url>%2F2019%2F06%2F26%2Fgenerator%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[再简单复习一下，generator 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function step1 (success) &#123; setTimeout(() =&gt; &#123; console.log('step1'); success(); &#125;, 1000);&#125;function step2 (success) &#123; setTimeout(() =&gt; &#123; console.log('step2'); success(); &#125;, 1000);&#125;function step3 (success) &#123; setTimeout(() =&gt; &#123; console.log('step3'); success(); &#125;, 1000);&#125;function* main () &#123; // generator 配合yield和next来实现异步编程， // yield让函数等待上一个执行完后再执行，next（）让执行指针跳到下下一个 yield step1; yield step2; yield step3;&#125;function run (fn) &#123; /** * 在fn，也就是main这个generator函数执行完后，会返回一个generator * .next后会返回下一个yield等待执行的信息，一个对象&#123;done: false value: ƒ step1()&#125; * 那么我们通过，这个对象中的done来判断，这个generator是否执行完成（false表示后面还有一不代码要执行） */let gen=fn() function next ()&#123; let result = gen.next(); console.log(result) if (result.done) return result.value(next); &#125; next();&#125;run (main)]]></content>
      <tags>
        <tag>ES6</tag>
        <tag>generator</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入了解vue响应式原理]]></title>
    <url>%2F2019%2F06%2F23%2F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[react一篇稍微深入]]></title>
    <url>%2F2019%2F06%2F20%2Freact%E4%B8%80%E7%AF%87%E7%A8%8D%E5%BE%AE%E6%B7%B1%E5%85%A5%2F</url>
    <content type="text"><![CDATA[setState( Object | fn, callback ) 在一个流程中（render3完成，页面dom得到更新，叫一个数据更新流程）多次setState，会合并为一个setState来调用，合并机制非常好，但是会出现问题 3.利用第一个参数函数形式解决 123456先前的statethis.setState(（prevState）=&gt; &#123;return &#123; &#125;&#125;)等同||this.setState(（prevState）=&gt; (&#123;&#125;)) 4.列表渲染key的重要性，是给到react内部去优化性能key在兄弟节点中是必须的 4.1. 虚拟dom的比对叫做 diff算法 不同的根节点的树，就不需要比较了，直接以新的替换 特性： 同级比较1.1 同级元素类型变了，那么就不再比较子元素，直接将老的树销毁，生成新的树替换1.2 同级元素相同，这时再递归比较子元素 子元素比较 react中支持key属性，当子元素拥有key是，react使用key来匹配原有数上的子元素以及最新树上的子元素，使用key来匹配，使得效率变得更高 # react实现虚拟dom就是一段，jsx语法对象 1.受控组件需要使用state数据去控制这个form元素 2.非受控组件不需要使用state数据去控制的表单元素 非受控组件input的默认值，用defaultValue={this.state.value} chexkoutbox 用defaultChecked # 生命周期三大阶段1.挂载 constructor（）在组件实例化的时候触发 不能在里面setState 1. 调用父类的z构造函数super（props） 2. 初始化数据 this.state = {} 3.绑定this指向 render（）渲染 默认进来一次，后续如果有更新会再次触发 使用setState要小心 componentDidMount() 组件挂载完成 1. 获取异步数据 2. 获取dom元素 componentWillMount()即将过期， 不要使用 static getDerivedStateFromProps ( props,state) 能够根据props数来设置state数据 1. 默认render之前调用一次 2. 后续数据有变化，重新render之前又会调用 3. 不能使用 this.setState 4. 需要 return {} | null 如果是2.更新 static getDerivedStateFromProps shouldComponentUpdate （nextProps， nextState） 这个组件是否是应该进行渲染？ 做性能优化 一般不去用他，推荐使用 PureComponent 如果使用了它，就不能再使用PureConponent ！ 需要返回中，布尔值，如果返回true -&gt; 更新生命周期函数往下执行，false -&gt; 不更新生命周期不往下执行 render getSnapshotBeforeUpdate(prevProps, prevState) 真实DOM渲染完成的前一刻触发此生命周期的任何返回值将作为参数传递给 componentDidUpdate()。 componentDidUpdate(prevProps, prevState, snapshot) snapshot 是 getSnapshotBeforeUpdate 返回的值 不能随意的去使用网络请求和setState。 除非加上了判断条件 3.销毁conmponentWillUnmounted 组件之间通信 父 -&gt; 子 props 子-&gt; 父 传递方法给子组件 兄-&gt; 弟 3.1.状态提升 3.2.使用第三方的中央事件管理器 （pubsub） 3.3.context Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。 let MyContest = React.createContext()创建一个context对象 MyContext.Provider 组件 供应商 MyContext.Consumer 组件 消费者， 开始结束标签内需要使用一个**函数**来return jsx，而这个函数接收一个参数，参数就是供应商的value数据 一.使用以上三步骤 ​ 二.在消费者组件使用 static ContextType = MyContext this.context接收数据 ​ 3.4.自己写一个bus 4.react官方提供的状态管理器 flux 第三方： Redux javascript的状态管理器，跟Vuex很相似 &gt; 单一数据源，整个应用的state被存储在一颗object tree中 1. 在redux的流程中任何时刻state，都不会发生变化，不能直接改变 2. state的改变不是改变原来的state，是生成了一个新的state替换旧的state， 3. Reducers不能改变state，生成一个新的state 去return（纯函数的概念） 纯函数：任何时候都不会修改参数，有相同的入参，一定会产生相同的出参（每次传入相同的参数，都会出现相同的返回值） react组件标签之间的内容不会自动渲染出来，会在props中传入children ref的三种使用手法Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素 ref=”myUL” this.refs.myUL ref={(target)=&gt;{this.myUL = target}} this.myUL 构造函数中定义 this.myUL = React.createRef()ref={this.myUL} 在元素标签上设置this.myUL.current 获取元素在组件标签内写内容，利用改组件的{this.props.children}来实现相vue中solt功能]]></content>
      <tags>
        <tag>react</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react一篇搞定入门]]></title>
    <url>%2F2019%2F06%2F17%2Freact%E4%B8%80%E7%AF%87%E6%90%9E%E5%AE%9A%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1.React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据 2.在 JavaScript 代码中将 JSX 和 UI 放在一起时，会在视觉上有辅助作用。它还可以使 React 显示更多有用的错误和警告消息。 react 2013.5开源 （轻量级视图层库 、虚拟dom） 对与虚拟dom，简单说就是，在render时 return出来的那段jsx，是一个js对象，称之为虚拟dom，它没有直接渲染到web页面上，react 通过diff算法对现象产生的虚拟dom和之前的比较，比较出最小的dom改变，然后去渲染web页面vue 2015 react 使用 cdn 链接的方式 自己搭建 webpack 的环境 使用一些官方或第三方的脚手架 cdn 链接的方式12&lt;script src="https://unpkg.com/react@16/umd/react.development.js"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"&gt;&lt;/script&gt; react react核心内容 react-dom react用来渲染真实dom的一个库 自己搭建 webapck 环境 npm init -y npm install –save-dev webpack webpack-cli webpack-dev-server npm install –save react react-dom npm install –save-dev @babel/core @babel/preset-env @babel/preset-react babel-loader 写 webpack 配置文件 写 babel 配置文件 src 文件夹 放源代码 public 文件夹 放静态资源文件 使用脚手架 create-react-app npm install -g create-react-app create-react-app 或者 npx create-react-app ReactDOM.render();一个ract项目只会调用一次两个参数，1.要渲染在页面上的内容(react元素 | html | 虚拟dom)2.要渲染在页面上的某个位置（挂载点） jsx 语法 单个根元素 单标签一定要闭合 img 必须要加alt属性 标签都是小写字母，组件首字母大写 class -&gt;className for -&gt;htmlFor jsx注: 使用js的注释{/* */}jsx 的插值表达式：使用单个花括号，来作为表达式只能是简单的单个表达式，不能是语句也不能是条件或循环语句如果需要使用条件，可采用三元运算符 实现v-html 需要使用 dangerouslySetInnerHTML 这个属性，dangerouslySetInnerHTML 这个属性需要接受一个对象的value 123456789let str = '&lt;h1&gt;hello react&lt;/h1&gt;';ReactDOM.render(&lt;div dangerouslySetInnerHTML=&#123;&#123; __html: str &#125;&#125;&gt;&lt;/div&gt;,documnet.getElementById('app'))// 最后显示的就是div包着h1标签&#123;&#123; __html: 插值html &#125;&#125;&#123; '' &#125; | &#123;false&#125; | &#123;null&#125; | &#123;underfined&#125;这种情况可以实现，v-if react中没有指令系统 组件 &amp; props react 中没有全局组件的概念，你需要使用哪个组件，就必须引入进来使用 一 . 组件定义 函数式组件 类组建 二. 函数组件的定义 定义一个函数，然后return出来一段jsx语法，这段jsx语法就是这个组件的模板内容 PS ：函数名就是组件名，首字母大写1const Hello =() =&gt; &#123; return &lt;h1&gt;&lt;/h1&gt;&#125; 三. 类定义的组件 定义一个类，类名就是组件名（首字母大写） 这个类需要继承，React.Component 这个基础组件 类中必须要有render函数，render函数return出来一段jsx语法，这段jsx语法就是这个组件的模板内容123class World extends React.Component &#123;render () &#123; return &lt;p&gt;&lt;/p&gt;&#125;&#125;` PS:组件更多注意事项 组件模板内容，如果需要换行去写，就是用（）包裹起来 没有用React，为什么要引入： jsxc是一个语法糖 由于转换后的代码中使用了React ,使用React就必须要引入 组件的props属性所有 React 组件都必须像纯函数一样保护它们的 props 不被更改 123function sum(a, b) &#123;return a + b;&#125; 调用组件的时候，在标签上写的属性，属性名就是一个prop props是个集合，prop是个具体的某个一个 Vue中使用props首先要在组件中定义props选项，而react不用 函数组件，所有prop会做为参数传递 1const Hello = (&#123;name,age&#125;) =&gt; &#123;&#125; 类组件所有prop会在this.props身上 12class World extends React.Component &#123;render () &#123; return &lt;p&gt;&lt;/p&gt;&#125;&#125; props默认值例如有一个World组件，那么默认的props就是，World.defaultProps = {name: ‘李四’} react 元素一. 什么叫做react元素，最基本的一个单元，任何标签都可以 看成一个react元素 虚拟DOM元素 | JSX代码中的任意标签 | 通过React.createElement 创建出来的js对象二. 如何区分React元素 与React组件组件就是一系列React元素的组成 三. 什么是元素变量 定义一个变量，变量值是一个React元素const div = hello state数据绑定的两种方式1.props2.state 私有 一. 什么叫有状态组件， 什么叫无状态组件组建有没有状态，主要看这个组件有没有state一般类组件就可以称为有状态组件，函数组件叫做无状态组件 二. 组件要有变化，两种方式 组件接收到的props有了变化 组件自身的state有变化三. 组件的state或props有变化，组件就会更新，更新的效果其实就是类组件的render函数重新执行，函数组件重新调用了PS: 如果要让组件有state, 首先要确保这个组件是类组件。 要在 构造函数中定义 状态的初始值。 写了 构造函数的话，就必须在构造函数的第一行调用父类的构造函数 super()12345678910class Clock extends React.Component &#123; // 让这个组件有自身的状态数据（state），通过 构造函数 constructor(props) &#123; super(props); // 调用父类的构造函数 // 通过 this.state 给组件赋初始的state值, 不能setState this.state = &#123; date: new Date() &#125; &#125; &#125; React.Fragment组件，效果像vue中template1import React, &#123;Frigment, Component&#125; from 'react' this 绑定的四种方法父 -&gt; 子 prop 子 -&gt; 父 调用子组件的时候，传递一个自己的方法下去，这个方法里面有修改自己state的功能更 子组件通过 this.props.propName() {/是一个方法名/} 一、事件处理函数需要主动修改 this 指向， 为什么不能使用 apply 与 call 呢。apply 与 call 会立即执行，而 bind 是返回一个新的函数 *2. 处理在 jsx 上面直接 bind 的方式，我们还有以下几种修改this指向的方式 jsx bind （不推荐） 箭头函数 （不推荐） 统一都在 构造函数中 去做 this 绑定 (推荐) 使用 实验性的 public class fields 语法 (推荐) func = () =&gt; {}react 性能优化 虽然react的defer算法可以根据虚拟dom的改变只渲染改变了的元素，但是父组件变了，子组件就会重新render， 在性能优化时能不渲染就不渲染，那么就要使用PureComponent基础组件 遵循原则： 不使用bind绑定this，因为bind返回的是新的方法 不使用箭头函数函数 统一在constructor中绑定this使用 实验性的 public class fields 语法 （就是方法这么定义 fn1 = () =&gt; {}）!!! 不遵循该规则，机会破坏React.PureComponent的性能优化 12&lt;Son age=&#123;this.state.age&#125; fn = &#123;this.fn1.bind(this)&#125;/&gt;&lt;Son age=&#123;this.state.age&#125; fn = &#123;()=&gt;&#123;console.log(123) &#125;&#125;/&gt; React.PureCompoent 会在组件内容，比较数据是否有更新，如果有就render。如果没有就不会 render 例如在父组件state的某个属性值变了，而子组件并没有依赖这个属性，那么要让子组件，不再次render ，那么就让子组件 class Son extends React.PureComponent {}]]></content>
      <tags>
        <tag>React</tag>
        <tag>入门</tag>
        <tag>核心概念</tag>
        <tag>jsx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo添加自定义音乐播放器]]></title>
    <url>%2F2019%2F06%2F16%2Fhexo%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%2F</url>
    <content type="text"><![CDATA[解决方案 1.使用音乐平台自己的插件 2.结合 MetingJS 使用 APlayer 3.使用 hexo-tag-aplayer 花里胡哨，一通乱搞法 使用音乐平台自己的插件 这里就以网易云做例子，登录网易云网页版 - 生成单曲的那种直接点进一首歌，可以在音乐封面下，看见生成外链的蓝色字，点击进入看提示操作 12345678910&lt;iframeframeborder="no"border="0"marginwidth="0"marginheight="0"width=330height=86src="//music.163.com/outchain/player?type=2&amp;id=420400344&amp;auto=1&amp;height=66"&gt;&lt;/iframe&gt; 生成歌单：进入我的主页-&gt;点击你想生成外链歌单的歌单-&gt;在歌单播放次数边上，有外链入口 123456789&lt;iframeframeborder="no"border="0"marginwidth="0"marginheight="0"width=330height=220src="//music.163.com/outchain/player?type=0&amp;id=2845370038&amp;auto=1&amp;height=430"&gt;&lt;/iframe&gt; > 可以在你想插入的地方插入，在mackdown中插入也是可以的,然后一些配置看官网的祥解吧 > 官方的外链，虽然很方便但缺点很明显，一些歌曲受版权保护无法生成外链，播放器样式单一不灵活 结合 MetingJS 使用 APlayer APlayer 目前广泛使用的 HTML5 音乐播放器，MetingJS 用于解析歌曲链接 另外还有一个dplayer用来插入视频 MetingJS Aplayer在文章中应用 新建 /layout/_widget/aplayer.ejs 在文章头部，添加 aplayer: true 然而不是所有的文章你都会去加音乐，所以在 /_partial/head.ejs 加上这段代码 12345```ejs &lt;% if (page.aplayer === true) &#123; %&gt; &lt;%- partial(&apos;_widget/aplayer&apos;) %&gt; &lt;% &#125; %&gt;``` 然后就是插入这个 1234567891011121314151617&lt;div class="aplayer" data-fixed="true" data-id="490697747" data-server="netease" data-type="playlist" data-order="random" data-autoplay="true" data-mutex="true" data-loop="all" data-list-folded="false" data-volume="0.7" fixed="true" data-listmaxheight="240px" data-theme="#FF4081"&gt;&lt;/div&gt;&lt;!--这个id就是网页中打开的音乐id，在网址后面--&gt; 我是在ejs文件全局引入 12345&gt; &lt;link href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css" rel="stylesheet"&gt;&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"&gt;&lt;/script&gt;&gt; &lt;!-- Import meting.js --&gt;&gt; &lt;script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"&gt;&lt;/script&gt;&gt; 参数 是否必须 默认值 描述&amp;可选值 data-id 是 单曲ID / 歌单ID / 专辑ID / 搜索关键词 data-server 是 音乐平台：netease,tencent,kugou,xiami,baidu data-type 是 音乐类型：song,playlist,album,search,artist data-autoplay 否 false 是否自动播放，移动端浏览器不支持该选项 data-mutex 否 true 播放时是否暂停其他APlayer对象 data-listmaxheight 否 340px 播放列表最高高度 data-preload 否 auto 音乐预加载模式：none, metadata, auto data-theme 否 #2980b9 主题色 data-mini 否 false 是否开启迷你模式 data-loop 否 all 循环方式：all, one, none data-order 否 list 播放顺序：list, random data-lrc 否 false data-list-folded 否 false 歌单列表初始时是否折叠 data-volume 否 0.7 用户未自定义前的默认初始化音量 12&gt;&gt; 配置参照这个官方表 Name Default Description container document.querySelector(‘.aplayer’) player container fixed false enable fixed mode, see more details mini false enable mini mode, see more details autoplay false audio autoplay theme ‘#b7daff’ main color loop ‘all’ player loop play, values: ‘all’, ‘one’, ‘none’ order ‘list’ player play order, values: ‘list’, ‘random’ preload ‘auto’ values: ‘none’, ‘metadata’, ‘auto’ volume 0.7 default volume, notice that player will remember user setting, default volume will not work after user set volume themselves audio - audio info, should be an object or object array audio.name - audio name audio.artist - audio artist audio.url - audio url audio.cover - audio cover audio.lrc - see more details audio.theme - main color when switching to this audio, it has priority over the above theme audio.type ‘auto’ values: ‘auto’, ‘hls’, ‘normal’ or other custom type, see more details customAudioType - see more details mutex true prevent to play multiple player at the same time, pause other players when this player start play lrcType 0 see more details listFolded false indicate whether list should folded at first listMaxHeight - list max height storageName ‘aplayer-setting’ localStorage key that store player setting 使用 hexo-tag-aplayer在文章中使用：hexo-tag-aplayer 1234567 npm install --save hexo-tag-aplayer //在站点的_config.yml中配置 aplayer: meting: true //使用 &#123;% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125;&#123;% meting "25718007" "netease" "song" "theme:#FF4081" "mode:circulation" "mutex:true" "listmaxheight:340px" "preload:auto" %&#125; [^这里说一句，meting和aplayer标签不可以同时使用] [^更多官方配置请上官网查看] 花里胡哨，一通乱搞法 当然，我把meting文件，aplayer文件，引入的是全局的，就是在主题的layou.ejs中引入 然后在那里加12345678910111213141516&lt;div class="aplayer" data-fixed="true" data-id="490697747" data-server="netease" data-type="playlist" data-order="random" data-autoplay="true" data-mutex="true" data-loop="all" data-list-folded="false" data-volume="0.7" fixed="true" data-listmaxheight="240px" data-theme="#FF4081"&gt;&lt;/div&gt;这段代码 然后，你以为能出来吗，不是的！我这么胡搞，他可能听话吗，3.试验后发现，只要在一篇文章中加入meting标签或者是aplayer标签就可以出现了]]></content>
      <tags>
        <tag>音乐播放器</tag>
        <tag>diy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域解决-vue]]></title>
    <url>%2F2019%2F06%2F10%2F%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3-vue%2F</url>
    <content type="text"><![CDATA[待更新… devServer.proxy Type: string | Object 如果你的前端应用和后端 API 服务器没有运行在同一个主机上，你需要在开发环境下将 API 请求代理到 API 服务器。这个问题可以通过 vue.config.js 中的 devServer.proxy 选项来配置。 devServer.proxy 可以是一个指向开发环境 API 服务器的字符串： 12345module.exports = &#123; devServer: &#123; proxy: 'http://localhost:4000' &#125;&#125; 这会告诉开发服务器将任何未知请求 (没有匹配到静态文件的请求) 代理到http://localhost:4000。 如果你想要更多的代理控制行为，也可以使用一个 path: options 成对的对象。完整的选项可以查阅 http-proxy-middleware 。 1234567891011121314module.exports = &#123; devServer: &#123; proxy: &#123; '/api': &#123; target: '&lt;url&gt;', ws: true, changeOrigin: true &#125;, '/foo': &#123; target: '&lt;other_url&gt;' &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>vue</tag>
        <tag>跨域请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deep&Shallow cloning]]></title>
    <url>%2F2019%2F06%2F09%2FDeep-Shallow-cloning%2F</url>
    <content type="text"><![CDATA[首先在js中数据类型分为两种，基础数据类型和引用数据类型JavaScript原始类型:Undefined、Null、Boolean、Number、String、SymbolJavaScript引用类型:Object 1.浅克隆浅克隆之所以叫浅克隆，是因为对象只会被克隆最外面一层，至于对象内的对象还是通过引用指向同一块内存2.个人理解：深拷贝，为解决对象（引用类型），复制时新旧对象使用同一块内存 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//基本类型的复制，传的是值，var obj=&#123;a:1,b:2,c:3,d:&#123;e:5&#125;&#125;;// var obj1=obj;// obj.a=2;// console.log(obj==obj1);//浅拷贝// function qian(obj)&#123;// var newobj=&#123;&#125;;// for( k in obj)&#123;// newobj[k]=obj[k];// &#125;// return newobj;// &#125;// var obj1=qian(obj);// obj1.d.e=6;// console.log(obj);//深拷贝function deep(obj)&#123; var newobj=&#123;&#125;; for( k in obj)&#123; //对遍历到的元素，进行类型判断 if(typeof obj[k]=="object")&#123; //对object类型的原素再次遍历判断 newobj[k]=deep(obj[k]); &#125;else&#123; //基本类型直接拷贝 newobj[k]=obj[k]; &#125; &#125; return newobj;&#125;var obj1=deep(obj);obj1.d.e=6;console.log(obj1==obj);//false// jquery 有提供一个$.extend可以用来做 Deep Copy。 var $ = require('jquery'); var obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3] &#125;; var obj2 = $.extend(true, &#123;&#125;, obj1); console.log(obj1.b.f === obj2.b.f); // false // 函数库lodash，有提供_.cloneDeep用来做 Deep Copy。 var _ = require('lodash'); var obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3] &#125;; var obj2 = _.cloneDeep(obj1); console.log(obj1.b.f === obj2.b.f); // false 下面的文字，鉴于掘金当然也有传闻中的，序列/反序列（JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串,这两个方法结合起来就能产生一个便捷的深克隆.）要想实现一个靠谱的深克隆方法,上一节提到的序列/反序列是不可能的 它存在这些坑1.他无法实现对函数 、RegExp等特殊对象的克隆2.会抛弃对象的constructor,所有的构造函数会指向Object3.对象有循环引用,会报错 1234567891011121314151617181920212223242526272829// 构造函数function person(pname) &#123; this.name = pname;&#125;const Messi = new person('Messi');// 函数function say() &#123; console.log('hi');&#125;;const oldObj = &#123; a: say, b: new Array(1), c: new RegExp('ab+c', 'i'), d: Messi&#125;;const newObj = JSON.parse(JSON.stringify(oldObj));// 无法复制函数console.log(newObj.a, oldObj.a); // undefined [Function: say]// 稀疏数组复制错误console.log(newObj.b[0], oldObj.b[0]); // null undefined// 无法复制正则对象console.log(newObj.c, oldObj.c); // &#123;&#125; /ab+c/i// 构造函数指向错误console.log(newObj.d.constructor, oldObj.d.constructor); // [Function: Object] [Function: person] 123456const oldObj = &#123;&#125;;oldObj.a = oldObj;const newObj = JSON.parse(JSON.stringify(oldObj));console.log(newObj.a, oldObj.a); // TypeError: Converting circular structure to JSON 如果，第一段代码都无法看懂，那推荐看更高深的解读掘金大佬：寻找海蓝96 https://juejin.im/post/5abb55ee6fb9a028e33b7e0a]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>深浅克隆</tag>
        <tag>深浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex]]></title>
    <url>%2F2019%2F06%2F05%2Fvue%E8%BF%9B%E9%98%B6vuex%2F</url>
    <content type="text"><![CDATA[vuex ? 状态管理器 Fulx 架构就像眼睛： 您自会知道什么时候用它 核心 store(仓库) state ： 状态 （类似组件中的data） getters ：对 state的派生，可以理解为store的 *计算属性 * mutations ：修改state的唯一操作就是提交mutation actions ： 类似于mutation ；主要用来处理异步操作 modules ： 对仓库分割成模块 辅助函数， 组件从仓库那东西的时候，使用辅助函数更方便 mapState（） ： state的辅助函数 mapGetters（）：getters的辅助函数 mapMutations（） ：mutations的辅助函数 mapActions（） ：actions的辅助函数 什么时候需要使用 vuex 当你不知道该不该用的时候，那就是不该用。（你自会知道什么时候需要用到它） 组件之间通信很复杂的情况下 项目中使用了路由，并且路由页面组件中需要通信的时候， 项目写着写着头发一大把掉的时候。 vuex的操作流程 先要有仓库，将我们项目中组件上需要共享的数据放置到我们 仓库中 state 的位置。 组件要使用 仓库 中 state 的数据，就从仓库里面拿出来用。 要修改仓库中 state 的数据， commit(提交) mutation dispath(派发) action -&gt; commit mutation 然后仓库中 state 数据发生变化，组件就会得到更新 ![流程][‘images/a.jpg’] vuex 的使用 安装 vuex npm install --save vuex 项目中 src/store/index.js 文件中创建仓库的实例对象 要 main.js new Vue 的地方配置一个 store 的选项。选项的值就是 2 中 仓库实例对象 如何将仓库中的数据拿到组件中去使用this.$store 就是仓库的实例对象(就像使用了vue-router，会在vue实例上会挂载$router $route) 直接使用 this.$store 的方式在组件 template 模板中使用 （不推荐） 组件中使用 计算属性 去拿 仓库的数据 12345678910​ computed: &#123; title () &#123; return this.$store.state.title &#125; &#125;//也可以是import &#123; mapState &#125; from ‘vuex’computed: mapState（['title']）//computed:mapState (&#123; pageTitle: state =&gt; state.title //pageTitle (state) &#123; return satte.title&#125;&#125;) 借助 vuex 提供的辅助函数 mapState mapState([]) - 组件的computed 的 key 必须要跟仓库中 state 里面某个key 相同 mapState({}) - 组件的computed 的 key 可以自定义。 将 mapState 与 组件自身的 computed 结合 （推荐） 123456789101112computed: &#123; ...mapState(['title']), firstName () &#123;​ return this.name.split('')[0] &#125;&#125;, 如何修改仓库中的数据 先需要在仓库中定义我们的mutation 在组件中提交这个mutaion this.$store.commit(‘mutaion的名字’, 要传递的参数) this.$store.commit({ ​ type: mutaion的名字, ​ 其余的参数 }) mapMutations 辅助函数 mutation不允许异步代码的 如何写异步代码在仓库中 actionsAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) 每一个action里面都可以写异步代码，但是action并不能修改state中的数据，真正修改数据的还是 mutaction 在组件中如何派发这个action this.$store.dispatch(‘action的名字’) mapActions 辅助函数 12345678910111213141516import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` &#125;) &#125;&#125; 6.6]]></content>
      <tags>
        <tag>vue</tag>
        <tag>核心</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由懒加载与组件复用问题]]></title>
    <url>%2F2019%2F06%2F05%2F%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[组件复用问题 路由懒加载 在你具体去哪个路由的时候，再加载对应组件 12345678910111213141516171819202122232425const router = new VueRouter(&#123; routes: [ &#123; path: '/', component: () =&gt; import('../views/Index/index.vue'), children: [ &#123; path: 'home', component: () =&gt; import('../views/Index/home.vue') &#125;, &#123; path: 'about', component: () =&gt; import('../views/Index/about.vue') &#125;, &#123; path: 'center', component: () =&gt; import('../views/Index/center.vue') &#125;, &#123; path: '', redirect: '/home' &#125; ] &#125;] &#125;)]]></content>
      <tags>
        <tag>vue</tag>
        <tag>核心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router]]></title>
    <url>%2F2019%2F06%2F05%2Fvue%E8%BF%9B%E9%98%B6vue-router%2F</url>
    <content type="text"><![CDATA[前端路由 vue-router 根据不同的请求地址，能够让页面上某个组件进行切换显示 1.安装vue-router npm i vue-router -D2.项目中选择某个位置放入一个坑，router-view这个组件3.项目中配置路由规则 ，最后要暴露出去路由器的实例对象4.在main.js中也就是new vue的地方需要将第三步中暴露出来的 router 实例对象配置 根组件的 router 选项 router-view 路由组件要显示的地方router-link 这是使用了路由之后，提供给我们的一个全局组件，他就是一个 a 标签，能帮我们实现路由的切换 props：-to ke -active-class 能够让我们修改高两类的名字 router-link 与 a标签的区别： 1. 默认情况下，a标签的链接需要写 # 而router-link不需要 2. router-link 可以帮助我们实现高亮的效果页面渲染后被点击的标签会带有一个class类名 1&lt;a href="#/home" class="router-link-exact-active router-link-active"&gt;点我切换显示home&lt;/a&gt; 在组件中里利用router-link-active这个类，来实现高亮效果 动态路由匹配 动态路径参数以冒号开头当我们使用上路由后，会在Vue的原型上挂载 两个属性 $routev 当前匹配的路由对象信息 $router 路由器的实例对象 12345&#123; // 通过 ：来指定后面的id是动态路由参数 path: '/detail/:id', component: Detail &#125; 当匹配到一个路由时，参数值会被设置到 this.$route.params,可以在每个组件内使用(zai template中可以省略this)this.$route.query可以拿到地址后面的参数，问号后面的参数不影响路由匹配 嵌套路由12345678910111213141516const routes = [ &#123; path: '/home', component: Home, children: [//通过children 来写子集 &#123; path: 'page1', component: page1 &#125;, &#123; path: 'page2', component: page2 &#125; ] &#125;] //子集路由地址前不用加斜杠/ 编程式导航 如何用 js 代码来控制路由的跳转$router.push() 跳转页面，新增一个历史记录$router.back() 后退$router.forward$router.go() 根据参数来看是前进还是后退$router.replace() 重定向，跳转页面，不加历史记录 router-link 上也可以加 replace等 命名路由通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。 123456789const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:userId', name: 'user', component: User &#125; ]&#125;) 要链接到一个命名路由，可以给 router-link 的 to 属性传一个对象： 1&lt;router-link :to="&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"&gt;User&lt;/router-link&gt; 这跟代码调用 router.push() 是一回事： 1router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;) 这两种方式都会把路由导航到 /user/123 路径。 命名视图有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar (侧导航) 和 main (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。 123&lt;router-view class="view one"&gt;&lt;/router-view&gt;&lt;router-view class="view two" name="a"&gt;&lt;/router-view&gt;&lt;router-view class="view three" name="b"&gt;&lt;/router-view&gt; 一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置 (带上 s)： 123456789101112const router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; default: Foo,//default会将Foo组件渲染在没有命名的视图里 a: Bar, b: Baz &#125; &#125; ]&#125;) 重定向与别名 重定向 123456const router = new VueRouter(&#123; routes: [ &#123; path: '/page1', component: page1&#125;, &#123; path: '*', redirect: '/home' &#125;//在路由规则中，地址在这条规则之前都没匹配上，那么这条规则就将地址重定向到/home页面 ]&#125;) 别名 alias 12345 const router = new VueRouter(&#123; routes: [ &#123; path: '/a', component: A, alias: '/b' &#125; ]&#125;) “别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。 路由组件传参在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。 使用 props 将组件和路由解耦： 布尔模式 12345678910111213141516const User = &#123; props: ['id'], template: '&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, props: true &#125;, // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项： &#123; path: '/user/:id', components: &#123; default: User, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125; ]&#125;) 就是在组件路由上配置props选项为true，这个就是布尔模式，如果 props 被设置为 true，route.params 将会被设置为组件属性，在组件中通过props：[,]来接收相应的参数，就可以在组件标签上使用该参数，不会受到url地址的约束 对象模式 如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态的时候有用。 123456const router = new VueRouter(&#123; routes: [ &#123; path: '/promotion/from-newsletter', component: Promotion, props: &#123; abc: 123 &#125; &#125; ]&#125;)// 函数模式 你可以创建一个函数返回 props。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。 123456const router = new VueRouter(&#123; routes: [ &#123; path: '/search', component: SearchUser, props: (route) =&gt; (&#123; query: route.query.qid: route.params.id&#125;) &#125; ]&#125;) URL /search?q=vue 会将 {query: ‘vue’} 作为属性传递给 SearchUser 组件。 HTML5 History 模式vue路由的两种模式 hash（默认）在url上存在#号 history 要修改当前路由模式可以在 实例化 路由器对象的时候设置 mode 选项 1234new VueRouter(&#123; mode: 'history', router&#125;) 这两种模式的区别 1.从外观上说，hash模式会在url地址上面有一个#号，而history没有，更像url地址 从原理上来说，hash模式是通过 window.onHashChange 这个事件来处理的，而history模式 是基于html5中history 新增的一些api， historty.pushState()\history.replaceState() \window.onpopstate 来实现的 history 模式需要后台的配合 window.onpopstate ：监听浏览器前进后退按钮，能触发这个事件新属性使用： 你上家公司使用的是什么模式？vue导航守卫 ( 路由拦截 )主要分三大块 全局 全局前置 beforeEach router.beforeEach((to,from,next) =&gt;{}) 全局解析守卫 beforeResolve 全局后置守卫 beforeEach router.beforeEach((to,from）=&gt;{}) 路由独享 beforeEnter 进入当前路由时 组件级别的 beforeRouteEnter (to, from, next) {} 进入当前组件时 beforeRouteUpdate (to, from, next) {} 进入当前组件时 beforeRouteLeave (to, from, next) {} 退出当前组件时 导航守卫的钩子函数 在路由发生变化的时候会主动触发的一些函数 作用场景 beforeEach 与 afterEach 能实现页面进度条的效果 登录拦截 先排除 组件级别 afterEach 排除 正常情况下，如果是后台管理系统的话，因为处理登录与注册页面之外其他的都需要做登录的拦截，那么就可以再 全局前置 里面去做。如果项目中只有那么一个到两个需要做拦截的页面，那么就可以再他们自己的路由独享里面去做。]]></content>
      <tags>
        <tag>vue</tag>
        <tag>核心</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基础3]]></title>
    <url>%2F2019%2F05%2F29%2Fvue%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%803%2F</url>
    <content type="text"><![CDATA[计算属性（computed）和侦听（watch） 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!-- //计算属性 --&gt;&lt;div id="app"&gt;&lt;p @click='deal("你好")'&gt;&#123;&#123;fullName&#125;&#125;&lt;/p&gt;&lt;!-- //wacth侦听 --&gt;&lt;p&gt;&#123;&#123;trans&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; msg:"计算属性与watch侦听的学习", firstName:'anni', lastName:'veter', trans:'' &#125;, methods:&#123; deal(str)&#123; this.fullName=str; &#125; &#125;, computed:&#123; fullName:&#123; get()&#123; return this.firstName+" "+this.lastName; &#125;, set(str)&#123; console.log(); this.firstName=str; &#125; &#125; &#125;, watch:&#123; fullName(newVal,oldVal)&#123; console.log(newVal); console.log(oldVal); this.trans="旧数据："+oldVal+"新数据："+newVal; &#125; &#125; &#125;)&lt;/script&gt; watch执行异步请求示例，音乐搜索 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;div id="music"&gt; &lt;h1&gt;音乐搜索&lt;/h1&gt; &lt;input type="text" placeholder="请输入要搜索的音乐" v-model="searchVal" ref="input"&gt; &lt;ul&gt; &lt;li v-for='item in musicList' :key='item._id' &gt;&#123;&#123; item.title &#125;&#125;&lt;/li&gt; &lt;p v-if="musicList.length===0"&gt;未找到匹配歌曲&lt;/p&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#music', data:&#123; searchVal:'',//存放搜索的数据 musicList:[]//放后台返回的数据 &#125;, watch:&#123; searchVal:&#123; //watch可以进行异步操作（一下这么写是为了，自动自行一次异步请求，不需要自请求一次，还是按原来的写） handler(newVal,oldVal)&#123; clearTimeout(this.timer); // console.log(this); //延时是为了防抖节流 this.timer = setTimeout(() =&gt; &#123; $.get('http://58.87.126.209:7001/api/v1/music', &#123;title:newVal&#125;, (res)=&gt;&#123; console.log(res); if(res.code === 0)&#123; this.musicList=res.data.list; // this.$refs.input.focus(); &#125;else&#123; alert('网络异常'); &#125; &#125;) &#125;,300) &#125;, immediate:true//通过这个属性，以当前值，执行回调和函数 &#125; &#125; &#125;)&lt;/script&gt; 总结一下：computed和watch的区别： 1.computed根据现有数据，计算出新的结果 2.watch没有返回值，watch可以进行异步操作，computed不能！！！ 3.watch可以侦听现有的data和computed的数据改变，进而执行相应的函数 mixin混入1234567891011121314151617181920212223242526272829303132333435//通过定义一个对象来存储mixin的选项（除了el，propsData）var common=&#123; data()&#123; return &#123;msg:'你好'&#125; &#125;, methods:&#123; fn1()&#123; console.log('common fn1'); &#125; &#125;, mounted()&#123; console.log('生命周期函数'); &#125; &#125; var vm1 = new Vue(&#123; el:'#app', mixins:[common],//混入 methods:&#123; fn1()&#123; console.log('你好'); &#125; &#125;, data:&#123; msg:'11111', text:'123' &#125;, mounted()&#123; console.log('生命'); &#125; &#125;) var vm2 = new Vue(&#123; el:'#app1', mixins:[common]//通过mixins挂载到vue实例身上 &#125;) 总结一下：1.方法以自身的为主2.data与自身data相同的，以自身为主3.生命周期函数，会先执混入的，在执行自身的 4.除了 el 与 propsData 这两个选项之外其他的选项都可以，混入。5.data如果是一个混入对象的选项，那么data需要使用工厂模式弄成一个方法，方法里面返回对象 组件、vue实例的template123456&lt;div id="app" @click='fn1'&gt; &lt;world/&gt; &lt;/div&gt; &lt;div id='app2'&gt; &lt;world/&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Vue.component('world',&#123; // 这里写法跟 mixin 很像，都是能够使用 new Vue 时传递的哪些选项。 // 1. el 与 propsData 不能用 // 2. data 必须是一个函数返回对象的形式。 // 3. 组件必须要有一个选项是，template 选项，这个选项指定我们组件的内容。(标签可以使用自闭和) //4.当全局组件和局部组件同名时，以局部组件为主 template:`&lt;div&gt;你好&lt;/div&gt;`, mounted()&#123; console.log(1); &#125;&#125;); new Vue(&#123; el:'#app', data:&#123; msg:'123' &#125;, components:&#123;//局部注册，通过components: 'world':&#123;//组件名：&#123;组件选项对象&#125; data()&#123; return &#123;msg:'world'&#125; &#125;, template: ` &lt;div&gt; &lt;h1 @click='fn1'&gt;我是 &#123;&#123;msg&#125;&#125; 组件&lt;/h1&gt; &lt;/div&gt; `, methods:&#123; fn1()&#123; console.log(123); &#125;&#125; &#125; &#125;, methods:&#123; fn1()&#123; console.log(121); &#125; &#125; &#125;) // vue 实例也可以设置 template 选项，当有tempalte选项的时候，挂载点会整个被tempalte模板内容给替换。 new Vue(&#123; el:'#app2', template:` &lt;input&gt;` &#125;) 组件组件本质上是一个拥有预定义选项的一个 Vue 实例 组件template的优化写法 直接使用 模板字符串的方式 使用单文件组件 （推荐） 使用 script 标签的方式(这里暂时用这种) 123&lt;div id="app"&gt; &lt;hi/&gt;&lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456789101112131415161718&lt;script id='h' type="text/x-template"&gt; &lt;div&gt; &lt;p&gt;我是一个组件，使用script标签写法实现的组件&lt;/p&gt; &lt;/div&gt;&lt;/script&gt; &lt;script&gt; Vue.component('hi',&#123; template:"#h" &#125;) new Vue(&#123; el:'#app', data:&#123; msg:'123456' &#125; &#125;) &lt;/script&gt; 组件通信12345678910111213141516171819202122&lt;div id="app"&gt; &lt;father/&gt;&lt;/div&gt; &lt;script src="./lib/vue.js"&gt;&lt;/script&gt; &lt;!-- 父组件 --&gt; &lt;script id="father" type="text/x-template"&gt; &lt;div&gt; &lt;h1&gt;我是父组件&lt;/h1&gt; &lt;son :name='sonName' :sex='sonSex' @msg='fn'/&gt; &lt;/div&gt; &lt;/script&gt; &lt;!-- 子组件 --&gt; &lt;script id="child" type="text/x-template"&gt; &lt;div&gt; &lt;h2&gt;我是子组件，受父组件调控&lt;/h2&gt; &lt;p&gt;我叫：&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;性别：&#123;&#123;sex&#125;&#125;&lt;/p&gt; &lt;button @click='tran("event")'&gt;18岁了，我想改名&lt;/button&gt; &lt;!-- 这里是直接改的props里的值，相当于改data中的数据，但是这里会报错 --&gt; &lt;button @click='tran2(&#123;name:"李立其",sex:"女"&#125;)'&gt;25岁，我想改变一下，我和父亲说&lt;/button&gt; &lt;/div&gt; &lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041 &lt;script&gt;// 父组件Vue.component('father',&#123; template:'#father', data()&#123; return &#123; sonName:'李四', sonSex:'男' &#125; &#125;, methods:&#123; // 与子通信方法 //接收子传递的信息 fn(payload)&#123; this.sonName=payload.name; this.sonSex=payload.sex; &#125; &#125;&#125;);//子组件Vue.component('son',&#123; template:'#child', props:['name','sex'], methods:&#123; tran(str)&#123; console.log(this.name); this.name='李云海'; &#125;, tran2(obj)&#123; // 子于父通信，触发父给的自定义事件msg，this.$emit('事件名'，参数) this.$emit('msg',obj); &#125; &#125;&#125;); new Vue(&#123; el:'#app' &#125;) // 子要与父通信，通过，父给设的自定义事件this.$emit()触发自定义方法 &lt;/script&gt;]]></content>
      <tags>
        <tag>vue</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue入门基础1，助解原码]]></title>
    <url>%2F2019%2F05%2F28%2Fvue%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%801%EF%BC%8C%E5%8A%A9%E8%A7%A3%E5%8E%9F%E7%A0%81%2F</url>
    <content type="text"><![CDATA[从html开始看–&gt;js 12345678910111213141516171819202122li&#123; width: 200px; height: 20px; line-height: 20px; border-bottom: 1px solid #333;&#125;/* .item--color&#123; background:green;&#125; */.tab&#123; color: red;&#125;.list--item&#123; width: 100px; height: 50px; margin: 0 auto;&#125;.p--color&#123; background: orange; text-align: center;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 &lt;div id="list"&gt; &lt;ul&gt; &lt;li class="item" :class="&#123; 'item--color' : curItem === index&#125;" v-for="(item,index) in 5" @click="color(index)" :key='item' :style="styleObj" &gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;hr&gt;//首页列表也跳转 &lt;button :class="&#123;'tab': curTab ===item.id&#125;" v-for="item in tabs" :key='item.id' @click="turn(item.id)" &gt;&#123;&#123;item.name&#125;&#125;&lt;/button&gt; &lt;div v-if=" curTab === 'home' "&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;/div&gt; &lt;div v-if="curTab === 'list'"&gt; &lt;h1&gt;列表页&lt;/h1&gt; &lt;/div&gt;&lt;hr&gt;//enter变色 &lt;div class="list--item"&gt; &lt;p :class="&#123;'p--color':curItem === p.id&#125;" v-for="p in listItem" :key="p.id" @mouseenter="over(p.id)" &gt;&#123;&#123;p.name&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839&lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el:'#list', data:&#123; curItem:0, styleObj:&#123; color:'red', background: 'rgba(120,150,255)', fontSize:"20px" &#125;, style:&#123; background:'origin' &#125;, curTab:"home", tabs:[ &#123;id:'home',name:'首页'&#125;, &#123;id:'list',name:'列表页'&#125; ], listItem:[ &#123;id:1,name:'李蕾'&#125;, &#123;id:2,name:'李明'&#125;, &#123;id:3,name:'李良'&#125;, &#123;id:4,name:'李华'&#125; ] &#125;, methods:&#123; color(index)&#123; this.curItem=index; &#125;, turn(id)&#123; this.curTab=id; &#125;, over(index)&#123; this.curItem=index; &#125; &#125; &#125;)&lt;/script&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue入门基础2]]></title>
    <url>%2F2019%2F05%2F28%2Fvue%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%802%2F</url>
    <content type="text"><![CDATA[条件渲染分组，v-if和v-for一起使用 对上一篇中v-if系列的一个补充拓展1.分组渲染 123456&lt;template v-if="ok"&gt;&lt;!--最后的渲染效果不会渲染temlate标签，该标签方便我们进行分组渲染，而不会然css样式出现无效--&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; 2.v-if 和 v-for 的混合使用 当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先;在大型数据遍历判断时，会造成性能的浪费，现阶段建议使用如下方法 123456&lt;div class="test"&gt; &lt;ul&gt; &lt;!-- 将有手机的学生信息列出，在v-for='item in msg' v-if='havephone'会造成性能的浪费--&gt; &lt;li v-for="item in msg.filter((value,index)=&gt;&#123;value.havephoe&#125;)" key="item.id"&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 12345678910111213new Vue(&#123; el:'.test', data:&#123; msg:[ &#123;id:1,name:'lisi',age:15,havephoe:false&#125; &#123;id:2,name:'lii',age:12,havephoe:false&#125; &#123;id:3,name:'lsi',age:12,havephoe:true&#125; &#123;id:4,name:'li',age:5,havephoe:false&#125; &#123;id:5,name:'lis',age:13,havephoe:false&#125; &#123;id:6,name:'lise',age:14,havephoe:ture&#125; ] &#125;&#125;) 事件处理 就是对v-on监听dom事件事件的修饰符 123456789101112131415161718192021 &lt;!-- 阻止单击事件继续传播(冒泡) --&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 (阻止默认事件)--&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once="doThis"&gt;&lt;/a&gt; 按键修饰符 1234&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.enter="submit" &gt;&lt;!-- pagedown --&gt;&lt;input v-on:keyup.page-down="onPageDown"&gt; 12 // 可以使用 `v-on:keyup.f1`Vue.config.keyCodes.f1 = 112 更多修饰符见官网（https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6）]]></content>
      <tags>
        <tag>vue</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue入门基础1]]></title>
    <url>%2F2019%2F05%2F27%2Fvue%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%801%2F</url>
    <content type="text"><![CDATA[vue使用是MVVM模式 基本指令 （前提是已安装vue或以将vue.js文件引入，详细操作见官方文档:(https://cn.vuejs.org/v2/guide/#%E8%B5%B7%E6%AD%A5)） 插值(在文本域插值只能用v-model)12345&lt;div class="app"&gt;&lt;!-- （可先跳过这段文字）这里只是给vue提供的挂载点，也就是vue.js将会通过el: '.app' （如果是id，就是el :'#类名'） --&gt; &lt;p&gt; &#123;&#123;message&#125;&#125;&#123;&#123;tip&#125;&#125;&lt;/p&gt; &lt;!-- 通过双花括号将数据带入，也可以带入一个单表达式 （这是一种模板语法）--&gt;&lt;/div&gt; 12345678910111213var app = new Vue(&#123; el : '.app',//vue只会操作或管理该节点内的节点（el===element） data :&#123;//需要渲染的数据 message : 'hello vue', tip: '名字随便写' &#125;, // method: &#123;&#125;, // computed:&#123;&#125;&#125;);//可以通过app.$mount('.app')添加挂载 下面的演示会解释的简单些，请理解以上插值的过程，再阅读一下文字 v-if &amp; v-else &amp; v-else-if &amp; v-show 1234&lt;div id="app"&gt; &lt;p v-if='height&gt;200'&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;p v-else&gt;你好&lt;/p&gt;&lt;/div&gt; v-if和v-else要相邻使用，如果中间有其他原素是达不到想要的效果的 12345678910&lt;script&gt; new Vue(&#123; el:'#app', data:&#123; message:'hello', height:155 &#125; &#125;)&lt;/script&gt;1234567891011121314151617 &lt;div id="app"&gt; &lt;p v-if='height&gt;100'&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;p v-else-if='height&gt;160'&gt;你好&lt;/p&gt; &lt;p v-else&gt;简单理解一下&lt;/p&gt; &lt;p v-show='height&gt;=155'&gt;在控制台查看通过v-if被隐藏的标签和v-show的区别&lt;/p&gt; &lt;p v-show='height&lt;155'&gt;隐藏&lt;/p&gt; &lt;/div&gt;//js代码 var app= new Vue(&#123; data: &#123; message: 'hello', height: 155 &#125; &#125;) app.$mount('#app');//通过vm.$mount('类名'),可以给vue添加挂载 v-if 与 v-show 的区别v-if判断结果为false会让原素变为html注释，而v-show则是给原素添加display属性 1. 他们都能实现元素的显示隐藏 2. v-show只是简单控制元素的display属性（不管条件为真还是为假，这个元素都会被渲染出来），而v-if才是条件渲染（条件为真，元素将会被渲染，条件为假，元素会被销毁） 3. v-show有更高的首次渲染开销。v-if的首次渲染开销要小得多。 4. v-if有更高的切换开销，v-show切换开销小 5. v-if有配套的 v-else-if 和 v-else，而v-show没有 v-once数据渲染一次，数据改变时，加了v-once的原素数据，保持第一次渲染的数据 v-text；v-html向html页面输出html元素(不推荐使用该方法，会带来xss攻击隐患) 12345&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;button&#125;&#125;&lt;/p&gt;//直接输出的是字符串 &lt;p v-html='button'&gt;&lt;/p&gt; &lt;p v-text='msg'&gt;你猜&lt;/p&gt;&lt;/div&gt; 12345678new Vue(&#123; el:'#app', data:&#123; msg: 'v-text注入信息，会将原标签内的数据给覆盖显示，使用了v-text/v-html，再在标签内写直接书写数据是不显示的' button:'&lt;button&gt;按钮&lt;/button&gt;' &#125;&#125;) v-bind属性、样式、类的绑定…,v-on绑定事件 1234567891011v-bind简写 ‘：’v-on简写‘@’&lt;div id="app"&gt;&lt;p v-bind:title='msg'&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;p v-bind:style="&#123; color: activeColor&#125;"&gt;121212&lt;/p&gt;&lt;p :class="&#123; box1 : isOk &#125;"&gt;11111&lt;/p&gt;&lt;p v-bind:[attrname]='msg'&gt;&lt;p&gt;&lt;!-- 动态属性绑定 --&gt;&lt;p :class='active'&gt;&lt;/p&gt;&lt;div @click='reverse()'&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/div&gt; 123456789101112131415new Vue(&#123; el:'#app', data:&#123; isOk:true, msg:'按钮', activeColor:'red', attrname:'title' &#125;, method:&#123; reverse()&#123; this.msg=this.msg.split('').reverse().join('') &#125; &#125; &#125;) v-model双向绑定 v-model绑定的数据改变，会实时刷新 1234567&lt;div id="app"&gt;&lt;p v-bind:title='msg'&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;input type='text' v-model.number='msg'&gt;&lt;input type='text' v-model.trim='msg'&gt;&lt;!--去除用户输入的前后的空格--&gt;&lt;input type='text' v-model.lazy='msg'&gt;&lt;!--model是实时更新数据的，加了lazy修饰符，就会在失去焦点时才写入数据--&gt;&lt;/div&gt;&lt;!-- 如果输入的值类型与修饰符的类型不同v-model.number这个number，vue会使用第一次输入值的类型，后续输入的会住哪换成该类型显示，转换不了就会抛弃 --&gt; 12345678910111213new Vue(&#123; el:'#app', data:&#123; msg:'按钮', activeColor:'red' &#125;, method:&#123; reverse()&#123; this.msg=this.msg.split('').reverse().join('') &#125; &#125; &#125;) v-for循环 12345678910111213 &lt;div class="app"&gt; &lt;p v-for='(item,index) in num' :key='index'&gt; &#123;&#123;item&#125;&#125;&lt;/p&gt; &lt;!-- 1. 如果在v-for的时候没有给循环的每一项设置一个唯一的标识符的话，那么后续这个数据发生变化，页面重新渲染，是完全的将之前的列表项给删掉然后重新渲染的。2. 如果给了唯一的标识的话，那么没有变化的，可以直接复用上。让性能更高效。我们需要确保的就是：每次 v-for 循环都需要给每一个循环项目加上唯一的标识，使用 v-bind:key=""最好不要使用下标来做唯一标示。使用数据中的唯一的属性。 --&gt; &lt;p v-for='(value,key,index) in obj'&gt; &#123;&#123;value&#125;&#125;&#123;&#123;key&#125;&#125;&#123;&#123;index&#125;&#125;&lt;/p&gt; &lt;p v-for='i in 10'&gt; &#123;&#123;i&#125;&#125;&lt;/p&gt; &lt;!-- 十次循环 --&gt; &lt;/div&gt; 123456789//可循环遍历对象，数组，字符串...new Vue(&#123; el:'.app', data:&#123; msg:'一段文字', num:[1,2,3,4,5,6], obj:&#123;name:'lili',age:15,sex:'男'&#125; &#125; &#125;) 其实vue中的数据绑定原理是这样的 ⬇ 1&lt;div id="box"&gt;&lt;/div&gt; 12345678910111213141516var boxEl = document.getElementById('box');// 使用es5 Object.defineProperty(boxEl, 'name', &#123; get: function () &#123; console.log('你要取值了'); return boxEl.innerHTML; &#125;, set: function (value) &#123; console.log('你要设置内容了'); boxEl.innerHTML = value; &#125;&#125;)// boxEl.name//获取数据，进入的是get方法// boxEl.name = '123123'//设置数据，进入set方法 解决浏览器渲染的跳动：给元素添加 v-cloak属性，再添加样式[v-cloak]{display:none},这样在浏览器渲染完成前，原始的在html中的数据是不会显示的 数据监测#### 数组： 使用一些变异方法或者直接替换数组都能引起页面的更新。 但是以下两个操作不会： 1. 直接根据数据下标来修改 vm.list[0] = 9; 2. 直接修改数据的长度 vm.list.length = 10; 解决方式： 1. 使用 Vue.set 原型方法 2. 使用 vm.$set 实例方法 Vue.set(target, index, value); vm.$set(target, index, value); 对象 Vue 不能检测对象属性的添加或删除： Vue.set(target, key, value); vm.$set(target, key, value); 如看完这些还不是很了解，请看 (https://zhan1025.github.io/2019/05/28/vue入门基础1，助解原码/)]]></content>
      <tags>
        <tag>vue</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gallery]]></title>
    <url>%2F2019%2F05%2F17%2Fgallery%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[H5动画API--requestAnimationFrame]]></title>
    <url>%2F2019%2F05%2F15%2FH5%E5%8A%A8%E7%94%BBAPI--requestAnimationFrame%2F</url>
    <content type="text"><![CDATA[在Web应用中，实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，css3 可以使用 transition 和 animation 来实现，html5 中的 canvas 也可以实现。除此之外，html5 还提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是请求动画帧。 为了深入理解 requestAnimationFrame 背后的原理，我们首先需要了解一下与之相关的几个概念： 1、屏幕刷新频率即图像在屏幕上更新的速度，也即屏幕上的图像每秒钟出现的次数，它的单位是赫兹(Hz)。 对于一般笔记本电脑，这个频率大概是60Hz， 可以在桌面上右键-&gt;屏幕分辨率-&gt;高级设置-&gt;监视器 中查看和设置。这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响，原则上设置成让眼睛看着舒适的值都行。 市面上常见的显示器有两种，即CRT和LCD， CRT就是传统显示器，LCD就是我们常说的液晶显示器。 CRT是一种使用阴极射线管的显示器，屏幕上的图形图像是由一个个因电子束击打而发光的荧光点组成，由于显像管内荧光粉受到电子束击打后发光的时间很短，所以电子束必须不断击打荧光粉使其持续发光。电子束每秒击打荧光粉的次数就是屏幕刷新频率。 而对于LCD来说，则不存在刷新频率的问题，它根本就不需要刷新。因为LCD中每个像素都在持续不断地发光，直到不发光的电压改变并被送到控制器中，所以LCD不会有电子束击打荧光粉而引起的闪烁现象。 因此，当你对着电脑屏幕什么也不做的情况下，显示器也会以每秒60次的频率正在不断的更新屏幕上的图像。为什么你感觉不到这个变化？ 那是因为人的眼睛有视觉停留效应，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了，这中间只间隔了16.7ms(1000/60≈16.7)， 所以会让你误以为屏幕上的图像是静止不动的。而屏幕给你的这种感觉是对的，试想一下，如果刷新频率变成1次/秒，屏幕上的图像就会出现严重的闪烁，这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。 2、动画原理根据上面的原理我们知道，你眼前所看到图像正在以每秒60次的频率刷新，由于刷新频率很高，因此你感觉不到它在刷新。而动画本质就是要让人眼看到图像被刷新而引起变化的视觉效果，这个变化要以连贯的、平滑的方式进行过渡。 那怎么样才能做到这种效果呢？ 刷新频率为60Hz的屏幕每16.7ms刷新一次，我们在屏幕每次刷新前，将图像的位置向左移动一个像素，即1px。这样一来，屏幕每次刷出来的图像位置都比前一个要差1px，因此你会看到图像在移动；由于我们人眼的视觉停留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置，因此你才会看到图像在流畅的移动，这就是视觉效果上形成的动画。 3、setTimeout理解了上面的概念以后，我们不难发现，setTimeout 其实就是通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的。但我们会发现，利用seTimeout实现的动画在某些低端机上会出现卡顿、抖动的现象。 这种现象的产生有两个原因： setTimeout的执行时间并不是确定的。在Javascript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此 setTimeout 的实际执行时间一般要比其设定的时间晚一些。 刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。 以上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。 那为什么步调不一致就会引起丢帧呢？ 首先要明白，setTimeout的执行只是在内存中对图像属性进行改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的图像。假设屏幕每隔16.7ms刷新一次，而setTimeout每隔10ms设置图像向左移动1px， 就会出现如下绘制过程： 第0ms: 屏幕未刷新，等待中，setTimeout也未执行，等待中； 第10ms: 屏幕未刷新，等待中，setTimeout开始执行并设置图像属性left=1px； 第16.7ms: 屏幕开始刷新，屏幕上的图像向左移动了1px， setTimeout 未执行，继续等待中； 第20ms: 屏幕未刷新，等待中，setTimeout开始执行并设置left=2px; 第30ms: 屏幕未刷新，等待中，setTimeout开始执行并设置left=3px; 第33.4ms:屏幕开始刷新，屏幕上的图像向左移动了3px， setTimeout未执行，继续等待中； … 从上面的绘制过程中可以看出，屏幕没有更新left=2px的那一帧画面，图像直接从1px的位置跳到了3px的的位置，这就是丢帧现象，这种现象就会引起动画卡顿。 4、requestAnimationFrame与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。具体一点讲，如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。 这个API的调用很简单，如下所示： 123456789101112131415161718192021222324var progress = 0;//回调函数function render() &#123; progress += 1; //修改图像的位置 if (progress &lt; 100) &#123; //在动画没有结束前，递归渲染 window.requestAnimationFrame(render); &#125;&#125;//第一帧渲染window.requestAnimationFrame(render); 除此之外，requestAnimationFrame还有以下两个优势： CPU节能：使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而requestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。 函数节流：在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次时没有意义的，因为显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。 5、优雅降级由于requestAnimationFrame目前还存在兼容性问题，而且不同的浏览器还需要带不同的前缀。因此需要通过优雅降级的方式对requestAnimationFrame进行封装，优先使用高级特性，然后再根据不同浏览器的情况进行回退，直止只能使用setTimeout的情况。下面的代码就是有人在github上提供的polyfill，详细介绍请参考github代码 requestAnimationFrame（https://github.com/darius/requestAnimationFrame） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748if (!Date.now) Date.now = function() &#123; return new Date().getTime(); &#125;;(function() &#123; 'use strict'; var vendors = ['webkit', 'moz']; for (var i = 0; i &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++i) &#123; var vp = vendors[i]; window.requestAnimationFrame = window[vp+'RequestAnimationFrame']; window.cancelAnimationFrame = (window[vp+'CancelAnimationFrame'] || window[vp+'CancelRequestAnimationFrame']); &#125; if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) // iOS6 is buggy || !window.requestAnimationFrame || !window.cancelAnimationFrame) &#123; var lastTime = 0; window.requestAnimationFrame = function(callback) &#123; var now = Date.now(); var nextTime = Math.max(lastTime + 16, now); return setTimeout(function() &#123; callback(lastTime = nextTime); &#125;, nextTime - now); &#125;; window.cancelAnimationFrame = clearTimeout; &#125;&#125;()); ====原文来自====：一像素www.cnblogs.com/onepixel/p/7078617.html]]></content>
      <tags>
        <tag>js</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-saga]]></title>
    <url>%2F2018%2F06%2F26%2Freact-saga%2F</url>
    <content type="text"><![CDATA[​ 首先中间件有很多，你可以把他当作一个函数，或者是说是一个模块，想必你用过 react-thunk ，react-logger…,那么thunk也可以完成saga的工作，只能说有的人喜欢挑战，就是要用saga主要是想让saga来处理异步请求操作 sagasaga自述 安装saga yarn add react-saga 在你的redux主仓库中添加， 123456789101112131415161718192021// 2. 引入saga 引入saga的主要处理文件import createSagaMiddleware from 'redux-saga';// @是配了别名的，写的路径就是你saga文件的路径import todoSaga from '@/views/TodoList/store/todoSaga';// 3.创建saga中间件const sagaMiddleware = createSagaMiddleware();...// 仓库暴露出去的东西export default createStore( combineReducers(&#123; todo: todoReducer &#125;), composeEnhancers( // 使用上中间件 applyMiddleware(sagaMiddleware)));// run todoSagasagaMiddleware.run(todoSaga) 在仓库中（我这边是组件的小仓库）创建saga文件 1234567891011121314151617181920212223242526// 注意这个，这里是saga提供的一些方法import &#123; takeEvery, put &#125; from 'redux-saga/effects';import &#123; FETCH_TODO_LIST &#125; from './actionTypes';import &#123; initTodoListAction &#125; from './actionCreates';// 处理一个异步请求function* init () &#123; let response = yield fetch('http://localhost:3001/todoList'); let res = yield response.json(); yield put (initTodoListAction(res));&#125; // 暴露一个方法const todoSaga = function *() &#123; // takeEvery('action type',要做的事情) // 监听/拦截到这个动作，进行操作 yield takeEvery(FETCH_TODO_LIST, init);&#125;export default todoSaga;/** *这边的saga作为中间件利用takeEvery拦截到组件（ui组件发出的action）， *对action.type做拦截，然后在这个文件里，做异步请求。在请求完成后再将数据通过 *saga提供的方法put===store.dispatch *派发了以后，会进入到reducer中，对仓库里的数据进行一些操作 */ 熟能生巧！]]></content>
      <tags>
        <tag>react</tag>
        <tag>saga</tag>
        <tag>redux</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC、MVP、MVVM]]></title>
    <url>%2F2018%2F06%2F23%2FMVC%E3%80%81MVP%E3%80%81MVVM%2F</url>
    <content type="text"><![CDATA[MVC(Model View Controller):视图（view）： 用户界面]]></content>
      <tags>
        <tag>MVVM</tag>
        <tag>MVC</tag>
        <tag>MVP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js经典问题汇总（持续更新...）]]></title>
    <url>%2F2017%2F06%2F22%2Fjs%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[捡空余时间，写点笔记 1.描述一下cookies、sessionStorage和loaclStorage区别 - sessionStorage用于本地存储一个会话的数据，会话结束就会清除（当你关闭浏览器，会话就结束了） - loaclStorage用于持久性的本地存储数据，除非自动清除，不然有就不会过期 - cookie 大小限制4k左右，每次请求新页面，cookie都会被发送出去总结： - 相同： 1.都有大小限制（cookie在4k左右，其他的在几兆左右） 2.都用于存储少量的数据，用户信息 - 差异： 1.sessionStorage在会话结束后，自动清除， 2.localStorage需要自动清除 3.cookie可以设置有效期，有效期之后会自动清除2.Sass、Scss、Less是什么？大家为什么要使用他们？ &gt; 都是css的预处理器，都含有变量，方法、继承、嵌套等概念， - sass与less使用{}来区分层级嵌套 - scss没有全局变量的概念 特点：结构清晰，便于扩展，可以轻松的实现多层继承3.闭包是什么，有什么特性，对页面有什么影响 闭包能读取其他函数内部的变量的函数 缺点：滥用闭包会造成内存泄露，因为闭包会把引用的变量存储起来，永远不会被释放（不会被辣鸡回收机制回收）4.事件委托是什么 利用事件冒泡原理，让本来有自己触发的事件，让他的父级元素代替执行]]></content>
      <tags>
        <tag>js</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
